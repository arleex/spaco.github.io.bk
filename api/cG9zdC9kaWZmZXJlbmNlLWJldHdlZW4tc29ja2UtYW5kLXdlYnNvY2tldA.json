{"title":"difference between socket and websocket","date":"2019-07-23T00:00:00.000Z","link":"post/difference-between-socke-and-websocket","tags":["socket & websocket"],"categories":["program"],"updated":"2019-07-23T00:00:00.000Z","content":"<p>Difference between socket and websocket </p>\n<h2 id=\"Socket\">Socket<a href=\"post/difference-between-socke-and-websocket#Socket\"></a></h2><blockquote>\n<p>套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。</p>\n<p>——百度百科</p>\n</blockquote>\n<p>Socket是一套API接口，是建立在TCP和应用程序之间的一个抽象层，就是我们之前说的“面向抽象编程”的这个抽象，Socket这个抽象层帮我们封装了TCP/UDP等网络协议的操作，让我们可以通过Socket提供的接口进行网络通信，可以通过一个图来说明这个抽象的功能</p>\n<h2 id=\"Websocket\">Websocket<a href=\"post/difference-between-socke-and-websocket#Websocket\"></a></h2><p><a href=\"https://en.wikipedia.org/wiki/WebSocket\" target=\"_blank\" rel=\"noopener\">wiki.websocket</a></p>\n<blockquote>\n<p><strong>WebSocket</strong>是一种<a href=\"https://zh.wikipedia.org/wiki/网络传输协议\" target=\"_blank\" rel=\"noopener\">通信协议</a>，可在单个<a href=\"https://zh.wikipedia.org/wiki/传输控制协议\" target=\"_blank\" rel=\"noopener\">TCP</a>连接上进行<a href=\"https://zh.wikipedia.org/wiki/全雙工\" target=\"_blank\" rel=\"noopener\">全双工</a>通信。WebSocket协议在2011年由<a href=\"https://zh.wikipedia.org/wiki/互联网工程任务组\" target=\"_blank\" rel=\"noopener\">IETF</a>标准化为<a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" rel=\"noopener\">RFC 6455</a>，后由<a href=\"https://tools.ietf.org/html/rfc7936\" target=\"_blank\" rel=\"noopener\">RFC 7936</a>补充规范。<a href=\"https://zh.wikipedia.org/w/index.php?title=Web_IDL&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">Web IDL</a>中的WebSocket API由<a href=\"https://zh.wikipedia.org/wiki/万维网联盟\" target=\"_blank\" rel=\"noopener\">W3C</a>标准化。</p>\n<p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p>\n</blockquote>\n<h3 id=\"简介\">简介<a href=\"post/difference-between-socke-and-websocket#简介\"></a></h3><blockquote>\n<p>WebSocket是一种与<a href=\"https://zh.wikipedia.org/wiki/超文本传输协议\" target=\"_blank\" rel=\"noopener\">HTTP</a>不同的协议。两者都位于<a href=\"https://zh.wikipedia.org/wiki/OSI模型\" target=\"_blank\" rel=\"noopener\">OSI模型</a>的<a href=\"https://zh.wikipedia.org/wiki/应用层\" target=\"_blank\" rel=\"noopener\">应用层</a>，并且都依赖于<a href=\"https://zh.wikipedia.org/wiki/传输层\" target=\"_blank\" rel=\"noopener\">传输层</a>的TCP协议。 虽然它们不同，但RFC 6455规定：“WebSocket设计为通过80和443端口工作，以及支持HTTP代理和中介”，从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头<a href=\"https://zh.wikipedia.org/wiki/WebSocket#cite_note-1\" target=\"_blank\" rel=\"noopener\">[1]</a>从HTTP协议更改为WebSocket协议。</p>\n<p>WebSocket协议支持Web<a href=\"https://zh.wikipedia.org/wiki/浏览器\" target=\"_blank\" rel=\"noopener\">浏览器</a>（或其他客户端应用程序）与Web<a href=\"https://zh.wikipedia.org/wiki/服务器\" target=\"_blank\" rel=\"noopener\">服务器</a>之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输。 服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。通过这种方式，可以在客户端和服务器之间进行双向持续对话。 通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。另外，<a href=\"https://zh.wikipedia.org/wiki/Comet_(web技术\" target=\"_blank\" rel=\"noopener\">Comet</a>)之类的技术以非标准化的方式实现了类似的双向通信。</p>\n<p>大多数浏览器都支持该协议，包括<a href=\"https://zh.wikipedia.org/wiki/Google_Chrome\" target=\"_blank\" rel=\"noopener\">Google Chrome</a>、<a href=\"https://zh.wikipedia.org/wiki/Firefox\" target=\"_blank\" rel=\"noopener\">Firefox</a>、<a href=\"https://zh.wikipedia.org/wiki/Safari\" target=\"_blank\" rel=\"noopener\">Safari</a>、<a href=\"https://zh.wikipedia.org/wiki/Microsoft_Edge\" target=\"_blank\" rel=\"noopener\">Microsoft Edge</a>、<a href=\"https://zh.wikipedia.org/wiki/Internet_Explorer\" target=\"_blank\" rel=\"noopener\">Internet Explorer</a>和<a href=\"https://zh.wikipedia.org/wiki/Opera瀏覽器\" target=\"_blank\" rel=\"noopener\">Opera</a>。</p>\n<p>与HTTP不同，WebSocket提供全双工通信。此外，WebSocket还可以在TCP之上启用消息流。TCP单独处理字节流，没有固有的消息概念。 在WebSocket之前，使用Comet可以实现全双工通信。但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。</p>\n<p>WebSocket协议规范将<code>ws</code>（WebSocket）和<code>wss</code>（WebSocket Secure）定义为两个新的<a href=\"https://zh.wikipedia.org/wiki/統一資源標識符\" target=\"_blank\" rel=\"noopener\">统一资源标识符</a>（URI）方案，分别对应明文和加密连接。除了方案名称和片段ID（不支持<code>#</code>）之外，其余的URI组件都被定义为此URI的通用语法。</p>\n<p>使用浏览器开发人员工具，开发人员可以检查WebSocket握手以及WebSocket框架。</p>\n</blockquote>\n<h3 id=\"背景\">背景<a href=\"post/difference-between-socke-and-websocket#背景\"></a></h3><blockquote>\n<p>现在，很多网站为了实现<a href=\"https://zh.wikipedia.org/wiki/推送技术\" target=\"_blank\" rel=\"noopener\">推送技术</a>，所用的技术都是<a href=\"https://zh.wikipedia.org/wiki/輪詢\" target=\"_blank\" rel=\"noopener\">轮询</a>。轮询是在特定的的时间间隔（如每秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的<a href=\"https://zh.wikipedia.org/wiki/HTTP头字段列表\" target=\"_blank\" rel=\"noopener\">头部</a>，其中真正有效的数据可能只是很小的一部分，显然这样会消耗很多的带宽资源。</p>\n<p>比较新的轮询技术是<a href=\"https://zh.wikipedia.org/wiki/Comet_(web技术\" target=\"_blank\" rel=\"noopener\">Comet</a>)。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的<a href=\"https://zh.wikipedia.org/wiki/HTTP持久链接\" target=\"_blank\" rel=\"noopener\">HTTP长连接</a>也会消耗服务器资源。</p>\n<p>在这种情况下，<a href=\"https://zh.wikipedia.org/wiki/HTML5\" target=\"_blank\" rel=\"noopener\">HTML5</a>定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p>\n<p>Websocket使用<code>ws</code>或<code>wss</code>的<a href=\"https://zh.wikipedia.org/wiki/统一资源标志符\" target=\"_blank\" rel=\"noopener\">统一资源标志符</a>，类似于<a href=\"https://zh.wikipedia.org/wiki/HTTPS\" target=\"_blank\" rel=\"noopener\">HTTPS</a>。其中<code>wss</code>表示使用了<a href=\"https://zh.wikipedia.org/wiki/TLS\" target=\"_blank\" rel=\"noopener\">TLS</a>的Websocket。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; ws://example.com/wsapi</span><br><span class=\"line\">&gt; wss://secure.example.com/wsapi</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>Websocket与HTTP和HTTPS使用相同的TCP<a href=\"https://zh.wikipedia.org/wiki/TCP/UDP端口列表\" target=\"_blank\" rel=\"noopener\">端口</a>，可以绕过大多数<a href=\"https://zh.wikipedia.org/wiki/防火墙\" target=\"_blank\" rel=\"noopener\">防火墙</a>的限制。默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。</p>\n</blockquote>\n<h3 id=\"优点\">优点<a href=\"post/difference-between-socke-and-websocket#优点\"></a></h3><blockquote>\n<ul>\n<li><p>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10<a href=\"https://zh.wikipedia.org/wiki/字节\" target=\"_blank\" rel=\"noopener\">字节</a>（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的<a href=\"https://zh.wikipedia.org/wiki/掩码\" target=\"_blank\" rel=\"noopener\">掩码</a>。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p>\n</li>\n<li><p>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的<a href=\"https://zh.wikipedia.org/w/index.php?title=长轮询&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">长轮询</a>比较，其也能在短时间内更多次地传递数据。</p>\n</li>\n<li><p>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p>\n</li>\n<li><p>更好的二进制支持。Websocket定义了<a href=\"https://zh.wikipedia.org/wiki/二进制\" target=\"_blank\" rel=\"noopener\">二进制</a>帧，相对HTTP，可以更轻松地处理二进制内容。</p>\n</li>\n<li><p>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持<a href=\"https://zh.wikipedia.org/wiki/数据压缩\" target=\"_blank\" rel=\"noopener\">压缩</a>等。</p>\n</li>\n<li><p>更好的压缩效果。相对于<a href=\"https://zh.wikipedia.org/wiki/HTTP压缩\" target=\"_blank\" rel=\"noopener\">HTTP压缩</a>，Websocket在适当的扩展支持下，可以沿用之前内容的<a href=\"https://zh.wikipedia.org/wiki/上下文\" target=\"_blank\" rel=\"noopener\">上下文</a>，在传递类似的数据时，可以显著地提高压缩率。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"握手协议\">握手协议<a href=\"post/difference-between-socke-and-websocket#握手协议\"></a></h3><blockquote>\n<p>WebSocket 是独立的、创建在 TCP 上的协议。</p>\n<p>Websocket 通过 <a href=\"https://zh.wikipedia.org/wiki/HTTP\" target=\"_blank\" rel=\"noopener\">HTTP</a>/1.1 协议的101<a href=\"https://zh.wikipedia.org/wiki/HTTP状态码\" target=\"_blank\" rel=\"noopener\">状态码</a>进行握手。</p>\n<p>为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“<a href=\"https://zh.wikipedia.org/wiki/握手_(技术\" target=\"_blank\" rel=\"noopener\">握手</a>)”（handshaking）。</p>\n</blockquote>\n<h2 id=\"Summary\">Summary<a href=\"post/difference-between-socke-and-websocket#Summary\"></a></h2><p>Websocket是一种应用层协议，Socket是封装了网络层操作的抽象API接口</p>\n<h2 id=\"References\">References<a href=\"post/difference-between-socke-and-websocket#References\"></a></h2><p><a href=\"https://zh.wikipedia.org/wiki/WebSocket\" target=\"_blank\" rel=\"noopener\">维基WebSocket</a></p>\n","prev":{"title":"program noun","link":"post/program-noun"},"next":{"title":"types-of-dependency-injection","link":"post/types-of-dependency-injection"},"plink":"https://spaco.github.io/post/difference-between-socke-and-websocket/","toc":[{"title":"Socket","id":"Socket","index":"1"},{"title":"Websocket","id":"Websocket","index":"2","children":[{"title":"简介","id":"简介","index":"2.1"},{"title":"背景","id":"背景","index":"2.2"},{"title":"优点","id":"优点","index":"2.3"},{"title":"握手协议","id":"握手协议","index":"2.4"}]},{"title":"Summary","id":"Summary","index":"3"},{"title":"References","id":"References","index":"4"}],"reward":true,"copyright":{"link":"<a href=\"https://spaco.github.io/post/difference-between-socke-and-websocket/\" title=\"difference between socket and websocket\">https://spaco.github.io/post/difference-between-socke-and-websocket/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}