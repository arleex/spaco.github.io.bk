{"title":"types-of-dependency-injection","date":"2019-07-15T00:00:00.000Z","link":"post/types-of-dependency-injection","tags":["IoC"],"categories":["program"],"updated":"2019-07-15T00:00:00.000Z","content":"<p>Types of Dependency Injection<br>此篇文章使用 Java 代码作为演示</p>\n<p>如果希望了解 Dependency Injection 和  Inversion of Control 可以参考··</p>\n<p>Spring通过DI（依赖注入）实现IoC（控制反转)</p>\n<p>建议看一下这篇文章</p>\n<p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies</a></p>\n<h2 id=\"Types\">Types<a href=\"post/types-of-dependency-injection#Types\"></a></h2><h3 id=\"Constructor-Injection\">Constructor Injection<a href=\"post/types-of-dependency-injection#Constructor-Injection\"></a></h3><p>基于构造函数的DI由容器调用具有多个参数的构造函数来完成，每个参数表示一个依赖项。 调用具有特定参数的静态工厂方法来构造bean几乎是等效的，本讨论同样处理构造函数和静态工厂方法的参数。 以下示例显示了一个只能通过构造函数注入进行依赖注入的类：</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleMovieLister</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MovieFinder movieFinder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleMovieLister</span><span class=\"params\">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.movieFinder = movieFinder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"Advantages\">Advantages<a href=\"post/types-of-dependency-injection#Advantages\"></a></h4><ul>\n<li>能够在构造阶段就创建完整、合法的对象；</li>\n<li>带有参数的构造函数可以明确地告诉你创建一个合法的对象需要哪些参数</li>\n</ul>\n<h4 id=\"Disadvantages\">Disadvantages<a href=\"post/types-of-dependency-injection#Disadvantages\"></a></h4><ul>\n<li><p>构造函数依赖的太多，会显得很复杂（事实上，当一个控制器依赖太多service，这个控制器本身就是有问题的，需要拆解）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleMovieLister</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> A a;</span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  \t<span class=\"keyword\">private</span> C c;</span><br><span class=\"line\">  \t<span class=\"keyword\">private</span> D d;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleMovieLister</span><span class=\"params\">(A a,B b,C c,D d)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">      \t<span class=\"keyword\">this</span>.b = b;</span><br><span class=\"line\">      \t<span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">      \t<span class=\"keyword\">this</span>.d = d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Setter-Injection-Property-Injection\">Setter Injection | Property Injection<a href=\"post/types-of-dependency-injection#Setter-Injection-Property-Injection\"></a></h3><p>在调用无参数构造函数或无参数<code>static</code>工厂方法来实例化bean之后，基于setter的DI由bean上的容器调用setter方法完成。</p>\n<p>以下示例显示了一个只能通过使用纯setter注入进行依赖注入的类。这个类是传统的Java。它是一个POJO，它不依赖于容器特定的接口，基类或注释。</p>\n<figure class=\"highlight java\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleMovieLister</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// the SimpleMovieLister has a dependency on the MovieFinder</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MovieFinder movieFinder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// a setter method so that the Spring container can inject a MovieFinder</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMovieFinder</span><span class=\"params\">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.movieFinder = movieFinder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"Advantages-1\">Advantages<a href=\"post/types-of-dependency-injection#Advantages-1\"></a></h4><ul>\n<li>如果依赖的「插件」太多时，选择 Setter 注入更优</li>\n</ul>\n<h4 id=\"Disadvantages-1\">Disadvantages<a href=\"post/types-of-dependency-injection#Disadvantages-1\"></a></h4><ul>\n<li><p>无法在构造阶段就创建完整、合法的对象；</p>\n</li>\n<li><p>带有参数的构造函数无法明确地告诉你创建一个合法的对象需要哪些参数</p>\n</li>\n</ul>\n<h3 id=\"Method-Injection-Function-Injection\">Method Injection | Function Injection<a href=\"post/types-of-dependency-injection#Method-Injection-Function-Injection\"></a></h3><p>What is method injection？</p>\n<p>Spring 中 Method Injection 分为 <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-lookup-method-injection\" target=\"_blank\" rel=\"noopener\">Lookup Method Injection</a> （查找方法注入）和 <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-arbitrary-method-replacement\" target=\"_blank\" rel=\"noopener\">Arbitrary Method Replacement</a>（任意方法替换）</p>\n<p>在大多数应用程序场景中，容器中的大多数bean都是 <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes-singleton\" target=\"_blank\" rel=\"noopener\">单例</a>。当单例bean需要与另一个单例bean协作或非单例bean需要与另一个非单例bean协作时，通常通过将一个bean定义为另一个bean的属性来处理依赖关系。当bean生命周期不同时会出现问题。假设单例bean A需要使用非单例（原型）bean B，可能是在A上的每个方法调用上。容器只创建一次单例bean A，因此只有一次机会来设置属性。每次需要时，容器都不能为bean A提供bean B的新实例。即 需要新实例。</p>\n<p>A solution is to forego some inversion of control. You can <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-aware\" target=\"_blank\" rel=\"noopener\">make bean A aware of the container</a> by implementing the <code>ApplicationContextAware</code> interface, and by <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-client\" target=\"_blank\" rel=\"noopener\">making a <code>getBean(&quot;B&quot;)</code> call to the container</a> ask for (a typically new) bean B instance every time bean A needs it. The following example shows this approach:</p>\n<h2 id=\"Summary\">Summary<a href=\"post/types-of-dependency-injection#Summary\"></a></h2><p>Constructor Injection 和 Setter Injection | Property Injection 是较常见的的注入方式，Method Injection 使用的较少。</p>\n<p>个人比较推荐 Constructor Injection，优点如上所述。</p>\n<p>还有一些文章说 Annotation Injection （注解注入）：通过注解将类注入到类属性中。个人感觉本质上和 Constructor Injection 没什么区别，都是初始化时将类注入到类属性中。</p>\n<p>不推荐以下写法，自己通过注解初始化类参数：</p>\n<p><strong>随着版本的迭代，开发者更注重于业务本身，而会忽略初始化的参数越来越多</strong></p>\n<figure class=\"highlight php\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Inject</span> A</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> A a;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Inject</span> B</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Inject</span> C</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> C c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"References\">References<a href=\"post/types-of-dependency-injection#References\"></a></h2><ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Dependency_injection\" target=\"_blank\" rel=\"noopener\">DI-wiki</a></li>\n<li><a href=\"https://spring.io/blog/2004/08/06/method-injection/\" target=\"_blank\" rel=\"noopener\">method-injection</a></li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies\" target=\"_blank\" rel=\"noopener\">docs.spring.io.beans-dependencies</a></li>\n<li><a href=\"https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/\" target=\"_blank\" rel=\"noopener\">A quick intro to Dependency Injection: what it is, and when to use it</a></li>\n<li><a href=\"https://www.tutorialsteacher.com/ioc/dependency-injection\" target=\"_blank\" rel=\"noopener\">Dependency Injection</a></li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html\" target=\"_blank\" rel=\"noopener\">spring-framework-reference.core</a></li>\n<li><a href=\"http://www.qingpingshan.com/rjbc/java/255320.html\" target=\"_blank\" rel=\"noopener\">Java方法注入（Method_injection）</a></li>\n<li><a href=\"https://www.c-sharpcorner.com/UploadFile/dacca2/understand-dependency-injection-functionmethod-injection/\" target=\"_blank\" rel=\"noopener\">Understand Dependency Injection: Function/Method Injection</a></li>\n<li><a href=\"https://my.oschina.net/zudajun/blog/664659\" target=\"_blank\" rel=\"noopener\">Spring查找方法注入(Lookup method injection)的底层实现原理</a></li>\n<li><a href=\"https://javabeat.net/difference-resource-autowired-inject-spring-injection/\" target=\"_blank\" rel=\"noopener\">Difference Between @Resource, @Autowired and @Inject in Spring Injection</a></li>\n</ul>\n","prev":{"title":"OSI - Open System Interconnection Reference Model","link":"post/OSI open-system-interconnection-reference-model"},"next":{"title":"laravel-queue-timeout-configuration-not-working","link":"post/laravel-queue-timeout-configuration-not-working"},"plink":"https://spaco.github.io/post/types-of-dependency-injection/","toc":[{"title":"Types","id":"Types","index":"1","children":[{"title":"Constructor Injection","id":"Constructor-Injection","index":"1.1","children":[{"title":"Advantages","id":"Advantages","index":"1.1.1"},{"title":"Disadvantages","id":"Disadvantages","index":"1.1.2"}]},{"title":"Setter Injection | Property Injection","id":"Setter-Injection-Property-Injection","index":"1.2","children":[{"title":"Advantages","id":"Advantages-1","index":"1.2.1"},{"title":"Disadvantages","id":"Disadvantages-1","index":"1.2.2"}]},{"title":"Method Injection | Function Injection","id":"Method-Injection-Function-Injection","index":"1.3"}]},{"title":"Summary","id":"Summary","index":"2"},{"title":"References","id":"References","index":"3"}],"reward":true,"copyright":{"link":"<a href=\"https://spaco.github.io/post/types-of-dependency-injection/\" title=\"types-of-dependency-injection\">https://spaco.github.io/post/types-of-dependency-injection/</a>","license":"自由转载-非商用-禁止演绎-保持署名 (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}