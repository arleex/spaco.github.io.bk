{"title":"PHP Garbage Collection","date":"2018-12-27T00:00:00.000Z","slug":"PHP-Garbage-Collection","tags":["php"],"categories":["program"],"updated":"2019-01-03T03:08:07.243Z","content":"<h2 id=\"Explains-Garbage-Collection-also-known-as-GC-of-PHP\"><a href=\"#Explains-Garbage-Collection-also-known-as-GC-of-PHP\" class=\"headerlink\" title=\"Explains Garbage Collection (also known as GC) of PHP\"></a>Explains Garbage Collection (also known as GC) of PHP</h2><h3 id=\"Related-concepts\"><a href=\"#Related-concepts\" class=\"headerlink\" title=\"Related concepts\"></a>Related concepts</h3><ul>\n<li><p>Garbage Collection : GC</p>\n</li>\n<li><p>PHP 5.2以前, PHP使用引用计数(Reference counting)来做资源管理,PHP 5.3才引入GC</p>\n</li>\n<li><p>zval  ：所有的变量都是用一个结构 zval 结构来保存的</p>\n<ul>\n<li>value : 值，是真正保存数据的关键部分，定义为一个联合体(union)</li>\n<li>type : 储存变量的类型 </li>\n<li>is_ref ：被 &amp; 引用的数量</li>\n<li>refcount ：引用计数，记录了当前的 zval 被引用的次数（这里的引用并不是真正的 &amp; ，而是有几个变量指向它）</li>\n</ul>\n</li>\n<li><p>Copy On Write  : COW</p>\n</li>\n<li><p>arithmetic</p>\n<p>PHP5.2 : <a href=\"http://php.net/manual/en/features.gc.refcounting-basics.php\" target=\"_blank\" rel=\"noopener\">Reference Counting</a> : 引用计数，GC根本算法</p>\n<p>PHP5.3 : <a href=\"http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf\" target=\"_blank\" rel=\"noopener\">Concurrent Cycle Collection in Reference Counted Systems</a></p>\n</li>\n<li><p>function : <a href=\"http://php.net/manual/en/function.memory-get-usage.php\" target=\"_blank\" rel=\"noopener\">memory_get_usage</a></p>\n</li>\n<li><p>function : xdebug_debug_zval() : need xdebug extension</p>\n</li>\n<li><p>function : <a href=\"http://php.net/manual/en/function.debug-zval-dump.php\" target=\"_blank\" rel=\"noopener\">debug_zval_dump</a></p>\n</li>\n</ul>\n<h3 id=\"PHP-Language-characteristics\"><a href=\"#PHP-Language-characteristics\" class=\"headerlink\" title=\"PHP Language characteristics\"></a>PHP Language characteristics</h3><p>PHP 是脚本语言，所谓脚本语言，就是说PHP并不是独立运行的，要运行PHP代码需要PHP解析器，用户编写的PHP代码最终都会被PHP解析器解析执行，PHP的执行是通过 <code>Zend engine</code>（ZE, Zend引擎），ZE是用C编写的，用户编写的PHP代码最终都会被翻译成PHP的虚拟机ZE的虚拟指令（<code>OPCODES</code>）来执行，也就说最终会被翻译成一条条的指令</p>\n<h3 id=\"Sketch-PHP5-3\"><a href=\"#Sketch-PHP5-3\" class=\"headerlink\" title=\"Sketch :PHP5.3\"></a>Sketch :PHP5.3</h3><ul>\n<li><p><code>zval sketch</code></p>\n<p>声明一个变量</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$addr = <span class=\"string\">'i value'</span>;</span><br></pre></td></tr></table></figure>\n<p>PHP内部都是使用 zval 来表示变量的，那对于上面的脚本，ZE是如何把 addr 和内部的 zval 结构联系起来的呢？变量都是有名字的（本例中变量名为 addr ），而 zval 中并没有相应的字段来体现变量名。PHP内部有一个机制，来实现变量名到 zval 的映射，在PHP中，所有的变量都会存储在一个 <code>hash table</code>中，当你创建一个变量的时候，PHP会为这个变量分配一个 zval，填入相应的信息，然后将这个变量的名字和指向这个 zval 的指针填入一个数组中。当你获取这个变量的时候，PHP会通过查找 hash table，取得对应的 zval</p>\n<p><code>注意：数组和对象这类复合类型在生成zval时，会为每个单元生成一个 zval</code></p>\n<p><img src=\"https://image-static.segmentfault.com/101/144/1011448460-569f6db18305e_articlex\" alt=\"\"></p>\n</li>\n</ul>\n<ul>\n<li><p><code>释放内存</code></p>\n<p>我们经常说每个变量都有一个内存地址，那这个 zval 和变量的内存地址，这俩有什么关系吗？定义一个变量会开辟一块内存，这块内存好比一个盒子，盒子里放了zval，zval里保存了变量的相关信息，需要开辟多大的内存，是由zval所占空间大小决定的，zval是内存对象，垃圾回收的时候会把zval和内存地址（盒子）分别释放掉</p>\n</li>\n<li><p><code>refcount  is_ref</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"string\">'string'</span>;</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\"><span class=\"keyword\">unset</span>($a);</span><br></pre></td></tr></table></figure>\n<p>第一行代码创建变量 a ,申请了 6 字节内存，</p>\n<p>第二行代码定义了变量 b, 将 a 的值赋予 b</p>\n<p>第三行代码释放了变量 a</p>\n<p>如果对于每一个变量重新分配内存，那么变量 a b要申请 12 字节的内存，并且变量 a,还是个无用的数据（被unset了），那么有没有什么方法节省这块资源呢？将变量 a b对应的指针指向同一个 zval 即可</p>\n<p><code>refcount</code></p>\n<p>refcount 指的是变量被引用的次数（reference count ?）,这里的引用并不是真正的 &amp; ，而是有几个变量指向它</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = $a;</span><br></pre></td></tr></table></figure>\n<p>第一行，创建了一个变量 a，变量值是 1。 此时保存int 1 的这个 zval 的 refcount 为 1<br>第二行，创建了一个新的整形变量（通过赋值的方式），变量也指向刚才创建的 zval，并将这个 zval 的 refcount 加1，此时这个 zval 的 refcount 为2<br>所以，这个时候（通过值传递的方式赋值给别的变量），并没有产生新的 zval，两个变量指向同一 zval，通过一个计数器来共用 zval 及内存地址，以达到节省内存空间的目的<br><code>当一个变量被第一次创建的时候，它对应的 zval 结构的 refcount 的值会被初始化为 1</code>，因为只有这一个变量在用它。但是当你把这个变量赋值给别的变量时，refcount 属性便会 加1 变成 2，因为现在有两个变量在用这个 zval 结构了</p>\n</li>\n<li><p><code>debug_zval_dump</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">debug_zval_dump($a);</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\">debug_zval_dump($a);</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long(<span class=\"number\">1</span>) refcount(<span class=\"number\">2</span>)</span><br><span class=\"line\">long(<span class=\"number\">1</span>) refcount(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>如果你奇怪 ，<code>var的refcount应该是1</code>啊？<br>我们知道，对于简单变量，PHP是以传值的形式传参数的。也就是说，当执行debug_zval_dump($var)的时候，var会以传值的方式传递给debug_zval_dump，也就是会导致var的refcount加1，所以只要能看到，当变量赋值给一个变量以后，能导致zval的refcount加 1</p>\n<p>例子：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\">$c = $b;</span><br><span class=\"line\">$d = $a;</span><br><span class=\"line\"><span class=\"comment\"># long(1) refcount(5)</span></span><br><span class=\"line\">debug_zval_dump($a);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>unset</code></p>\n<p>当 unset(var) 的时候，它删除符号表里的var的信息，准备清理它对应的zval及内存空间，这时它发现var对应的zval结构的 refcount 值是 &gt; 1，也就是说，还有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了</p>\n<p>例子：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\"><span class=\"keyword\">unset</span>($a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># long(1) refcount(2)</span></span><br><span class=\"line\">debug_zval_dump($b);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Copy On Write</code></p>\n<p>写入时复制是指：在 用变量对变量进行赋值时，这些相同值的变量指向同一块内存，只有当这些指向同一块内存的 相同值的变量 中的某一个变量的值 <code>发生改变</code>的时候，才需要进行<code>变量分离</code>，即：将 值发生改变的变量分离出来</p>\n<p>使用场景：变量的多次赋值；函数的参数传递。</p>\n<p>PHP中，Zend引擎为了区分同一块内存是否被多个变量引用，在zval结构中定义了ref_count和is_ref两个变量。</p>\n<p>ref_count定义了内存被变量引用的次数，次数为0时销毁</p>\n<p>is_ref定义了变量是否被强制引用，被强制引用时，值为1</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\"></span><br><span class=\"line\">$a 的 is_ref = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>例子：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\">$a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># long(2) refcount(2)</span></span><br><span class=\"line\">debug_zval_dump($a);</span><br><span class=\"line\"><span class=\"comment\"># long(1) refcount(2)</span></span><br><span class=\"line\">debug_zval_dump($b);</span><br></pre></td></tr></table></figure>\n<p>PHP在修改一个变量以前，会首先查看这个变量的refcount，如果refcount大于1，PHP就会执行一个分离的过程（在Zend引擎中，分离是破坏一个引用对的过程）对于上面的代码，当执行到第三行的时候，PHP发现var想要改变，并且它指向的zval的refcount大于1，那么PHP就会复制一个新的zval出来，改变其值，将改变的变量指向新的zval（，并将原zval的refcount减1，并修改symbol_table里该变量的指针，使得 a 和 b 分离(Separation)。这个机制就是所谓的copy on write（写时复制，这里的写包括普通变量的修改及数组对象里的增加、删除单元操作）</p>\n</li>\n<li><p><code>Change On Write</code></p>\n<p>使用变量复制的时候 ，PHP内部并不是真正的复制，而是采用指向相同的zval结构来节约开销。那么，对于PHP中的引用，又是如何实现呢</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$reference = &amp;$a;</span><br><span class=\"line\">$a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># refcount(2)  is_ref(1)</span></span><br><span class=\"line\">xdebug_debug_zval( <span class=\"string\">'a'</span> );</span><br></pre></td></tr></table></figure>\n<p>代码运行结果，$a 会被改为 2, 这个过程叫做 <code>change on write</code>, ZE 如何得知是否采用 Separation ？这个需要用到 </p>\n<p>$a 的 is_ref属性，它代表是否被 &amp; 引用，变量的 is_ref 默认为 0 ，大于 0则表示被引用，当 is_ref &gt; 0 或者 refcount = 1,此时不需要 Separation，而是直接修改 zval 的值</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>($if_ref || $refcount = <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\"># alter zval instead of Separation</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>尽管已经存在写时复制和写时改变，但仍然还存在一些不能通过is_ref和refcount来解决的问题</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$var = <span class=\"number\">1</span>;</span><br><span class=\"line\">$var_dup = $a;</span><br><span class=\"line\">$var_ref = &amp;$var;</span><br></pre></td></tr></table></figure>\n<p>当执行第二行代码的时候,变量的值必须分离成两份完全独立的存在，也就是说php将一个zval的isref从0设为1之前，当然此时refcount还没有增加，会看该zval的refcount，如果refcount&gt;1，则会分离, 将var_dup分离出去，并将var和var_ref做change on write关联。也就是，refcount=2, is_ref=1;<br>所以内存会给变量var_dup 分配出一个新的zval，类型与值同 var和var_ref指向的zval一样，是新分配出来的，尽管他们拥有同样的值，但是必须通过两个zval来实现。试想一下，如果三者指向同一个zval的话，改变 vardup的值，那么var和 var_ref 也会受到影响，这样是错误的</p>\n<p><img src=\"https://image-static.segmentfault.com/238/459/2384596612-569f6e23462c4_articlex\" alt=\"\"></p>\n<p>类似的：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://image-static.segmentfault.com/113/070/113070557-569f6e35da911_articlex\" alt=\"\"></p>\n</li>\n<li><p><code>debug_zval_dump()中参数是引用的话，refcount永远为1</code></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># long(1) refcount(1)</span></span><br><span class=\"line\">debug_zval_dump($a);</span><br></pre></td></tr></table></figure>\n<p>PHP先看变量指向的zval是否被引用，如果是引用，则不再产生新的zval<br>甭管哪个变量引用了它，比如有个变量a被引用了，b=&amp;a，就算自己引用自己a=&amp;a，a所指向的zval都不会被复制，改变其中一个变量的值，另一个值也被改变（change on write）<br>如果is_ref为0且refcount大于1，改变其中一个变量时，复制新的zval（copy on write）</p>\n</li>\n</ul>\n<h3 id=\"Reference-Counting\"><a href=\"#Reference-Counting\" class=\"headerlink\" title=\"Reference Counting\"></a>Reference Counting</h3><p>PHP5.2中使用的内存回收算法是<a href=\"http://en.wikipedia.org/wiki/Reference_counting\" target=\"_blank\" rel=\"noopener\">Reference Counting</a>，中文叫做“引用计数”，其思想非常直观和简洁：为每个内存对象分配一个计数器，当一个内存对象建立时计数器初始化为1（因此此时总是有一个变量引用此对象），以后每有一个新变量引用此内存对象，则计数器加1，而每当减少一个引用此内存对象的变量则计数器减1，当垃圾回收机制运作的时候，将所有计数器为0的内存对象销毁并回收其占用的内存。而PHP中内存对象就是zval，而计数器就是refcount。</p>\n<p>Important : <a href=\"http://php.net/manual/en/features.gc.refcounting-basics.php\" target=\"_blank\" rel=\"noopener\">Reference Counting Basics</a></p>\n<p>出现的问题 ： 引用的值为变量自身，内存泄漏 -&gt; <a href=\"http://php.net/manual/en/features.gc.refcounting-basics.php\" target=\"_blank\" rel=\"noopener\">泄露实例</a></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"keyword\">array</span>( <span class=\"string\">'one'</span> );</span><br><span class=\"line\">$a[] =&amp; $a;</span><br><span class=\"line\">xdebug_debug_zval( <span class=\"string\">'a'</span> );</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 类似如下</span></span><br><span class=\"line\">a: (refcount=2, is_ref=1)=array (</span><br><span class=\"line\">   0 =&gt; (refcount=1, is_ref=0)=<span class=\"string\">'one'</span>,</span><br><span class=\"line\">   1 =&gt; (refcount=2, is_ref=1)=...</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>图示：</p>\n<div class=\"article-img\"><p><img src=\"http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-loop-array.png\" alt=\"\"></p></div>\n<p>能看到数组变量 (a) 同时也是这个数组的第二个元素(1) 指向的变量容器中“refcount”为 <em>2</em>。上面的输出结果中的”…”说明发生了递归操作, 显然在这种情况下意味着”…”指向原始数组。</p>\n<p>跟刚刚一样，对一个变量调用unset，将删除这个符号，且它指向的变量容器中的引用次数也减1。所以，如果我们在执行完上面的代码后，对变量 a 调用unset, 那么变量 $a 和数组元素 “1” 所指向的变量容器的引用次数减1, 从”2”变成”1”. 下例可以说明:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unset</span>($a);</span><br><span class=\"line\"></span><br><span class=\"line\">xdebug_debug_zval( <span class=\"string\">'a'</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">(refcount=<span class=\"number\">1</span>, is_ref=<span class=\"number\">1</span>)=<span class=\"keyword\">array</span> (</span><br><span class=\"line\">   <span class=\"number\">0</span> =&gt; (refcount=<span class=\"number\">1</span>, is_ref=<span class=\"number\">0</span>)=<span class=\"string\">'one'</span>,</span><br><span class=\"line\">   <span class=\"number\">1</span> =&gt; (refcount=<span class=\"number\">1</span>, is_ref=<span class=\"number\">1</span>)=...</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<div class=\"article-img\"><p><img src=\"http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-leak-array.png\" alt=\"\"></p></div>\n<p>清除变量引起的问题：</p>\n<p>尽管不再有某个作用域中的任何符号指向这个结构(就是变量容器)，由于数组元素“1”仍然指向数组本身，所以这个容器不能被清除 。因为没有另外的符号指向它，用户没有办法清除这个结构，结果就会导致<code>内存泄漏</code>。庆幸的是，php将在脚本执行结束时清除这个数据结构，但是在php清除之前，将耗费不少内存。如果你要实现分析算法，或者要做其他像一个子元素指向它的父元素这样的事情，这种情况就会经常发生。当然，同样的情况也会发生在对象上，实际上对象更有可能出现这种情况，因为对象总是隐式的被引用。</p>\n<p>如果上面的情况发生仅仅一两次倒没什么，但是如果出现几千次，甚至几十万次的内存泄漏，这显然是个大问题。这样的问题往往发生在长时间运行的脚本中，比如请求基本上不会结束的守护进程(deamons)或者单元测试中的大的套件(sets)中。后者的例子：在给巨大的eZ(一个知名的PHP Library) 组件库的模板组件做单元测试时，就可能会出现问题。有时测试可能需要耗用2GB的内存，而测试服务器很可能没有这么大的内存。</p>\n<h3 id=\"Concurrent-Cycle-Collection-in-Reference-Counted-Systems\"><a href=\"#Concurrent-Cycle-Collection-in-Reference-Counted-Systems\" class=\"headerlink\" title=\"Concurrent Cycle Collection in Reference Counted Systems\"></a>Concurrent Cycle Collection in Reference Counted Systems</h3><p>PHP5.3的垃圾回收算法仍然以引用计数为基础，但是不再是使用简单计数作为回收准则，而是使用了一种同步回收算法，这个算法由IBM的工程师在论文<a href=\"http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf\" target=\"_blank\" rel=\"noopener\">Concurrent Cycle Collection in Reference Counted Systems</a>中提出。 </p>\n<p>首先PHP会分配一个固定大小的“根缓冲区”，这个缓冲区用于存放固定数量的zval，这个数量默认是10,000，如果需要修改则需要修改源代码Zend/zend_gc.c中的常量GC_ROOT_BUFFER_MAX_ENTRIES然后重新编译。</p>\n<p>由上文我们可以知道，一个zval如果有引用，要么被全局符号表中的符号引用，要么被其它表示复杂类型的zval中的符号引用。因此在zval中存在一些可能根（root）。这里我们暂且不讨论PHP是如何发现这些可能根的，这是个很复杂的问题，总之PHP有办法发现这些可能根zval并将它们投入根缓冲区。</p>\n<p>当根缓冲区满额时，PHP就会执行垃圾回收，此回收算法如下：</p>\n<ol>\n<li><p>对每个根缓冲区中的根 zval 按照<code>深度优先遍历算法</code>遍历所有能遍历到的 zval ，并将每个 zval 的 refcount 减1，同时为了避免对同一 zval 多次减1（因为可能不同的根能遍历到同一个 zval ），每次对某个zval减1后就对其标记为“已减”。</p>\n</li>\n<li><p>再次对每个缓冲区中的根 zval 深度优先遍历，如果某个 zval 的 refcount 不为0，则对其加1，否则保持其为0。</p>\n</li>\n<li><p>清空根缓冲区中的所有根（注意是把这些 zval 从缓冲区中清除而不是销毁它们），然后销毁所有 refcount 为0的zval，并收回其内存。</p>\n</li>\n</ol>\n<p>如果不能完全理解也没有关系，只需记住PHP5.3的垃圾回收算法有以下几点特性：</p>\n<ol>\n<li><p>并不是每次 refcount 减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收。</p>\n</li>\n<li><p>可以解决循环引用问题。</p>\n</li>\n<li><p>可以总将内存泄露保持在一个阈值以下。</p>\n</li>\n</ol>\n<h3 id=\"PHP-5-2-与-PHP-5-3-垃圾回收算法的性能比较\"><a href=\"#PHP-5-2-与-PHP-5-3-垃圾回收算法的性能比较\" class=\"headerlink\" title=\"PHP 5.2 与 PHP 5.3 垃圾回收算法的性能比较\"></a>PHP 5.2 与 PHP 5.3 垃圾回收算法的性能比较</h3><p><a href=\"http://php.net/manual/en/features.gc.performance-considerations.php\" target=\"_blank\" rel=\"noopener\">参考 PHP Manual</a></p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><ul>\n<li><p><a href=\"http://php.net/manual/en/features.gc.php\" target=\"_blank\" rel=\"noopener\">PHP Manual GC</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000004340427\" target=\"_blank\" rel=\"noopener\">zval _ 引用计数 _ 变量分离 _ 写时拷贝</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000008481434\" target=\"_blank\" rel=\"noopener\">浅谈PHP5中垃圾回收算法(Garbage Collection)的演化</a></p>\n</li>\n</ul>\n","prev":{"title":"","slug":"Elasticsearch-sketch"},"next":{"title":"DB migration Flyway","slug":"DBmigration-flyway"},"link":"https://spaco.github.io/post/PHP-Garbage-Collection/","toc":[{"title":"Explains Garbage Collection (also known as GC) of PHP","id":"Explains-Garbage-Collection-also-known-as-GC-of-PHP","index":"1","children":[{"title":"Related concepts","id":"Related-concepts","index":"1.1"},{"title":"PHP Language characteristics","id":"PHP-Language-characteristics","index":"1.2"},{"title":"Sketch :PHP5.3","id":"Sketch-PHP5-3","index":"1.3"},{"title":"Reference Counting","id":"Reference-Counting","index":"1.4"},{"title":"Concurrent Cycle Collection in Reference Counted Systems","id":"Concurrent-Cycle-Collection-in-Reference-Counted-Systems","index":"1.5"},{"title":"PHP 5.2 与 PHP 5.3 垃圾回收算法的性能比较","id":"PHP-5-2-与-PHP-5-3-垃圾回收算法的性能比较","index":"1.6"},{"title":"References","id":"References","index":"1.7"}]}]}