{"title":"MQ sketch","date":"2018-11-30T09:39:43.311Z","slug":"message-queue-sketch","tags":["MQ"],"categories":["program"],"updated":"2018-11-30T09:39:43.312Z","content":"<h2 id=\"MQ-简述\"><a href=\"#MQ-简述\" class=\"headerlink\" title=\"MQ 简述\"></a>MQ 简述</h2><h3 id=\"什么是MQ\"><a href=\"#什么是MQ\" class=\"headerlink\" title=\"什么是MQ\"></a>什么是MQ</h3><p>消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。 </p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p><code>当不需要立即获得结果，但是并发量又需要进行控制的时候，差不多就是需要使用消息队列的时候。</code></p>\n<ul>\n<li>异步处理</li>\n<li>应用解耦</li>\n<li>流量削峰</li>\n<li>else</li>\n</ul>\n<h3 id=\"使用与否\"><a href=\"#使用与否\" class=\"headerlink\" title=\"使用与否\"></a>使用与否</h3><ul>\n<li>使用</li>\n</ul>\n<h3 id=\"譬如\"><a href=\"#譬如\" class=\"headerlink\" title=\"譬如\"></a>譬如</h3><ul>\n<li>过安检，检测器处理能力有限，同时这些行李又不能丢了，加了个传送带，慢慢过检测器。其实这个传送带就是消息队列</li>\n<li>用户下单后，24小时未支付，需要取消订单。以前我们可能是定时任务循环查询，然后取消订单。实际上，我更推荐类似延迟MQ的方式，避免了很多无效的数据库查询，将一个MQ设置为24小时后才让消费者消费掉，这样很大程度上能减轻服务器压力</li>\n<li>帖子更新，关注者收到信息</li>\n</ul>\n<h3 id=\"场景举例\"><a href=\"#场景举例\" class=\"headerlink\" title=\"场景举例\"></a>场景举例</h3><h4 id=\"异步处理\"><a href=\"#异步处理\" class=\"headerlink\" title=\"异步处理\"></a>异步处理</h4><p><code>用户提交信息注册后，网站需要给用户发送邮件和短信</code></p>\n<p>传统做法</p>\n<p>将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端</p>\n<div class=\"article-img\"><p><img src=\"https://upload-images.jianshu.io/upload_images/3625649-8c99197d62d75a8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p></div>\n<p>不考虑网络等其他开销，耗费时间150ms</p>\n<p>优化：</p>\n<p>引入消息队列，用户的响应时间相当于是注册信息写入数据库的时间，也就是50ms。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50ms。</p>\n<div class=\"article-img\"><p><img src=\"https://upload-images.jianshu.io/upload_images/3625649-4e11f0cf468eae74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p></div>\n<h3 id=\"应用解耦\"><a href=\"#应用解耦\" class=\"headerlink\" title=\"应用解耦\"></a>应用解耦</h3><p><code>凌晨进行数据统计task,这些task之间有一定的数据依赖关系</code></p>\n<p>task3 需要使用task2的输出作为输入，task2 需要使用task1的输出作为输入，这样的话，tast1, task2, task3之间就有任务依赖关系，必须 task1 先执行，再 task2 执行，再 task3 执行。</p>\n<h4 id=\"不使用MQ\"><a href=\"#不使用MQ\" class=\"headerlink\" title=\"不使用MQ\"></a>不使用MQ</h4><ul>\n<li>方案<ol>\n<li>task1，0:00 执行，经验执行时间为 50 分钟</li>\n<li>task2，1:00 执行（为 task1 预留 10 分钟 buffer），经验执行时间也是 50 分钟</li>\n<li>task3，2:00 执行（为 task2 预留 10 分钟 buffer）</li>\n</ol>\n</li>\n</ul>\n<div class=\"article-img\"><p><img src=\"https://upload-images.jianshu.io/upload_images/3625649-d91218036c0ccc6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/740\" alt=\"image.png\"></p></div>\n<ul>\n<li>问题<ol>\n<li>如果有一个任务执行时间超过了预留 buffer 的时间，将会得到错误的结果</li>\n<li>总任务的执行时间变长，总是要预留很多 buffer，如果前置任务提前完成，后置任务不会提前开始</li>\n<li>如果有一个任务的执行时间要调整，将会有多个任务的执行时间要调整</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"使用MQ\"><a href=\"#使用MQ\" class=\"headerlink\" title=\"使用MQ\"></a>使用MQ</h4><ul>\n<li>方案<ol>\n<li>task1 准时开始，结束后发一个“task1 done”的消息</li>\n<li>task2 订阅 “task1 done” 的消息，收到消息后第一时间启动执行，结束后发一个 “task2 done” 的消息</li>\n<li>task3 订阅 “task2 done” 的消息，收到消息后第一时间启动执行</li>\n</ol>\n</li>\n<li>优点<ol>\n<li>不需要预留 buffer，上游任务执行完，下游任务总会在第一时间被执行</li>\n<li>依赖多个任务，被多个任务依赖都很好处理，只需要订阅相关消息即可</li>\n<li>有任务执行时间变化，下游任务都不需要调整执行时间</li>\n</ol>\n</li>\n</ul>\n<p><code>MQ只用来传递上游任务执行完成的消息，并不用于传递真正的输入输出数据。</code></p>\n<h3 id=\"流量削峰\"><a href=\"#流量削峰\" class=\"headerlink\" title=\"流量削峰\"></a>流量削峰</h3><p><code>系统A一天中大部分时间每秒请求并发数量就 100 多个，但是中午12点-1点每秒请求并发量就飙升到 10000 多个，但是系统每秒最大能处理的请求量只有 1000 多</code></p>\n<p><code>秒杀业务：上游发起下单操作,下游完成秒杀业务逻辑（库存检查，库存冻结，余额检查，余额冻结，订单生成，余额扣减，库存扣减，生成流水，余额解冻，库存解冻）\n上游下单业务简单，每秒发起了10000个请求，下游秒杀业务复杂，每秒只能处理2000个请求，很有可能上游不限速的下单，导致下游系统被压垮</code></p>\n<ul>\n<li><p>不使用MQ</p>\n<p>过大流量引起服务器崩溃</p>\n</li>\n<li><p>使用MQ</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3625649-549ab8216b0dfa8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n</li>\n</ul>\n<h3 id=\"引入MQ带来的问题\"><a href=\"#引入MQ带来的问题\" class=\"headerlink\" title=\"引入MQ带来的问题\"></a>引入MQ带来的问题</h3><ul>\n<li><p><strong>可用性降低</strong> 系统引入的外部依赖越多，越容易挂掉，MQ 挂掉之后会导致整个系统不可用。</p>\n</li>\n<li><p><strong>复杂度提高</strong> 重复消费、消息丢失、消息的顺序性等这些都是引入 MQ 之后需要考虑的事情</p>\n</li>\n<li><p><strong>一致性问题</strong> </p>\n<p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，就会导致数据不一致</p>\n</li>\n</ul>\n","next":{"title":"Principle of laravel","slug":"laravel-principle"},"link":"https://spaco.github.io/post/message-queue-sketch/","toc":[{"title":"MQ 简述","id":"MQ-简述","index":"1","children":[{"title":"什么是MQ","id":"什么是MQ","index":"1.1"},{"title":"使用场景","id":"使用场景","index":"1.2"},{"title":"使用与否","id":"使用与否","index":"1.3"},{"title":"譬如","id":"譬如","index":"1.4"},{"title":"场景举例","id":"场景举例","index":"1.5","children":[{"title":"异步处理","id":"异步处理","index":"1.5.1"}]},{"title":"应用解耦","id":"应用解耦","index":"1.6","children":[{"title":"不使用MQ","id":"不使用MQ","index":"1.6.1"},{"title":"使用MQ","id":"使用MQ","index":"1.6.2"}]},{"title":"流量削峰","id":"流量削峰","index":"1.7"},{"title":"引入MQ带来的问题","id":"引入MQ带来的问题","index":"1.8"}]}]}